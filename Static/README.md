# static

## 修饰变量

### 局部变量

在局部变量之前加上关键字static，局部变量就被定义成为一个局部静态变量。

内存中的位置：data段

初始化：只能回初始化一次

作用域：局部作用域

> 当static用来修饰局部变量的时候，它就**改变了局部变量的存储位置（从原来的栈中存放改为静态存储区）及其生命周期（局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问），但未改变其作用域。**

### 全局变量

在全局变量之前加上关键字static，全局变量就被定义成为一个全局静态变量

内存中的位置：静态存储区（静态存储区在整个程序运行期间都存在）

初始化：未经初始化的全局静态变量会被程序自动初始化为0

作用域：全局静态变量在声明他的文件之外是不可见的。准确地讲从定义之处开始到文件结尾。(只能在本文件中存在和使用)

> 全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的（在其他源文件中使用时加上extern关键字重新声明即可）。 而**静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它**。

## 修饰函数

修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。（和全局变量一样限制了作用域而已）

## 在类中使用

### 成员变量

用static修饰类的数据成员实际使其成为类的全局变量，会被类的所有对象共享，包括派生类的对象。

因此，**static成员必须在类外进行初始化，而不能在构造函数内进行初始化。不过也可以用const修饰static数据成员在类内初始化**

### 成员函数

用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，不含this指针。

静态成员是可以独立访问的，也就是说，无须创建任何对象实例就可以访问。

**不可以同时用const和static修饰成员函数**

```cpp
static const void func1()
{
    std::cout << "static const func" << std::endl;
}

// 错误，静态成员函数不能加const修饰
// static void func2() const
// {
//     std::cout << "static func2" << std::endl;
// }
```

C++编译器在实现const的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数const this*。但当一个成员为static的时候，该函数是没有this指针的。也就是说此时const的用法和static是冲突的。两者的语意是矛盾的。**static的作用是表示该函数只作用在类型的静态变量上，与类的实例没有关系；而const的作用是确保函数不能修改类的实例的状态**，与类型的静态变量没有关系。因此不能同时用它们。
