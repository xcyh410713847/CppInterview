# Variable

## 左值和右值

[【Modern C++】深入理解左值、右值](https://mp.weixin.qq.com/s/_9-0iNUw6KHTF3a-vSMCmg)

分类基于表达式的两个特征：

* **具名(identity)**:可以确定表达式是否与另一表达式指代同一实体，例如通过比较它们所标识的对象或函数的（直接或间接获得的）地址
* **可被移动**：移动构造函数、移动赋值运算符或实现了移动语义的其他函数重载能够绑定于这个表达式

### 左值(lvalue, left value)

具名且不可被移动

左值(lvalue,left value)，顾名思义就是赋值符号左边的值。准确来说，左值是表达式结束（不一定是赋值表达式）后依然存在的对象。

可以将左值看作是一个关联了名称的内存位置，允许程序的其他部分来访问它。在这里，我们将 "名称" 解释为任何可用于访问内存位置的表达式。所以，如果 arr 是一个数组，那么 arr[1] 和 *(arr+1) 都将被视为相同内存位置的“名称”。

左值具有以下特征：

* 可通过取地址运算符获取其地址
* 可修改的左值可用作内建赋值和内建符合赋值运算符的左操作数
* 可以用来初始化左值引用(后面有讲)

那么哪些都是左值呢?查了相关资料，做了些汇总，基本覆盖了所有的类型：

* 变量名、函数名以及数据成员名
* 返回左值引用的函数调用
* 由赋值运算符或复合赋值运算符连接的表达式，如(a=b, a-=b等)
* 解引用表达式*ptr
* 前置自增和自减表达式(++a, ++b)
* 成员访问（点）运算符的结果
* 由指针访问成员（ `->` ）运算符的结果
* 下标运算符的结果(`[]`)
* 字符串字面值("abc")

为了能够更加清晰地理解左值，我们举例：

```cpp
int a = 1; // a是左值
T& f();
f();//左值
++a;//左值
--a;//左值
int b = a;//a和b都是左值
struct S* ptr = &obj; // ptr为左值
arr[1] = 2; // 左值
int *p = &a; // p为左值
*p = 10; // *p为左值
class MyClass{};
MyClass c; // c为左值
"abc"
```

**对于一个表达式，凡是对其取地址（&）操作可以成功的都是左值**

### 将亡值(xvalue, expiring value)

具名且可被移动

### 纯右值(pvalue, pure ravlue)

不具名且可被移动

字面值或者函数返回的非引用都是纯右值

纯右值特征：

* 等同于C++11之前的右值
* 不会是多态
* 不会是抽象类型或数组
* 不会是不完全类型

以下表达式的值都是纯右值：

* 字面值(字符串字面值除外)，例如1，'a', true等
* 返回值为非引用的函数调用或操作符重载，例如：str.substr(1, 2), str1 + str2, or it++
* 后置自增和自减表达式(a++, a--)
* 算术表达式
* 逻辑表达式
* 比较表达式
* 取地址表达式
* lambda表达式

为了加深对右值的理解，下面的例子是常见的纯右值：

```cpp
nullptr;
true;
1;
int fun();
fun();

int a = 1;
int b = 2;
a + b;

a++;
b--;

a > b;
a && b;
```

### 泛左值(glvalue, generalized lvalue)

具名，lvalue和xvalue都属于glvalue

### 右值(rvalue, right value)

可被移动的表达式，prvalue和xvalue都属于rvalue

## 引用

在C++11之前，引用分为左值引用和常量左值引用两种，但是自C++11起，引入了右值引用，也就是说，在C++11中，包含如下3中引用：

* 左值引用
* 常量左值引用(不希望被修改)
* 右值引用

## 存储类型

在C++语言中，变量的存储类共有如下四种：

（1）auto存储类（自动存储类）

（2）static存储类 （静态存储类）

（3）extern存储类  (外部存储类)

（4）register存储类（寄存器存储类）

### 自动存储类

auto存储类，即自动存储类。在函数内部定义的变量，如果不指定其存储类，那么它就是auto类变量。这个是最常见的，所以我们不加关键字auto

这是我们经常见到的一种变量存储类型。见如下代码：

```c++
void func( ) { int a; auto int b; … }
//a和b都是auto存储类变量
```

> 自动存储类在在进入代码块（函数）之前生成，在函数体内部存活，出了函数体（函数返回）后就消失。
>
> 自动变量默认初始值是不确定的、
>
> 自动存储类每调用一次函数时都要赋一次初始值

### 静态存储类

static关键字

### extern存储类

如果在一个文件中要引用另一个文件中定义的外部变量，则在此文件中应用extern关键字把此变量说明为外部的。例如：

```c++
extern int a; //a为别的文件中定义的外部变量
int mydata; //外部变量的定义 
extern int mydata;  //外部变量的说明 
```

> 大型程序为了易于维护和理解，通常需要把程序划分为多个文件来保存，每个文件都可以单独编译，最后再把多个文件的编译结果（即目标文件）连接到一起来生成一个可执行程序。这种情况下，如果在一个文件中需要引用另一个文件中的外部变量，就需要利用extern说明。

### register存储类

为了提高某些自动类变量或函数参数的处理速度，可以在定义这些变量的类型说明符的前面加上register关键字，以通知编译系统为这些变量分配寄存器来存放其值。若使用register（而非auto）存储类标识代码块内的变量，编译器就会将变量缓存于处理器内的寄存器中，此种情况下不能对该变量或其成员变量使用引用操作符&以获取其地址，因为&只能获取内存空间中的地址

## 目录说明

### variable-left

左值

### variable-reference

与引用相关的左右值
