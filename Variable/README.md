# Variable

## 左值和右值

[【Modern C++】深入理解左值、右值](https://mp.weixin.qq.com/s/_9-0iNUw6KHTF3a-vSMCmg)

分类基于表达式的两个特征：

* **具名(identity)**:可以确定表达式是否与另一表达式指代同一实体，例如通过比较它们所标识的对象或函数的（直接或间接获得的）地址
* **可被移动**：移动构造函数、移动赋值运算符或实现了移动语义的其他函数重载能够绑定于这个表达式

### 左值(lvalue, left value)

具名且不可被移动

左值(lvalue,left value)，顾名思义就是赋值符号左边的值。准确来说，左值是表达式结束（不一定是赋值表达式）后依然存在的对象。

可以将左值看作是一个关联了名称的内存位置，允许程序的其他部分来访问它。在这里，我们将 "名称" 解释为任何可用于访问内存位置的表达式。所以，如果 arr 是一个数组，那么 arr[1] 和 *(arr+1) 都将被视为相同内存位置的“名称”。

左值具有以下特征：

* 可通过取地址运算符获取其地址
* 可修改的左值可用作内建赋值和内建符合赋值运算符的左操作数
* 可以用来初始化左值引用(后面有讲)

那么哪些都是左值呢?查了相关资料，做了些汇总，基本覆盖了所有的类型：

* 变量名、函数名以及数据成员名
* 返回左值引用的函数调用
* 由赋值运算符或复合赋值运算符连接的表达式，如(a=b, a-=b等)
* 解引用表达式*ptr
* 前置自增和自减表达式(++a, ++b)
* 成员访问（点）运算符的结果
* 由指针访问成员（ `->` ）运算符的结果
* 下标运算符的结果(`[]`)
* 字符串字面值("abc")

为了能够更加清晰地理解左值，我们举例：

```cpp
int a = 1; // a是左值
T& f();
f();//左值
++a;//左值
--a;//左值
int b = a;//a和b都是左值
struct S* ptr = &obj; // ptr为左值
arr[1] = 2; // 左值
int *p = &a; // p为左值
*p = 10; // *p为左值
class MyClass{};
MyClass c; // c为左值
"abc"
```

**对于一个表达式，凡是对其取地址（&）操作可以成功的都是左值**

### 将亡值(xvalue, expiring value)

具名且可被移动

### 纯右值(pvalue, pure ravlue)

不具名且可被移动

字面值或者函数返回的非引用都是纯右值

纯右值特征：

* 等同于C++11之前的右值
* 不会是多态
* 不会是抽象类型或数组
* 不会是不完全类型

以下表达式的值都是纯右值：

* 字面值(字符串字面值除外)，例如1，'a', true等
* 返回值为非引用的函数调用或操作符重载，例如：str.substr(1, 2), str1 + str2, or it++
* 后置自增和自减表达式(a++, a--)
* 算术表达式
* 逻辑表达式
* 比较表达式
* 取地址表达式
* lambda表达式

为了加深对右值的理解，下面的例子是常见的纯右值：

```cpp
nullptr;
true;
1;
int fun();
fun();

int a = 1;
int b = 2;
a + b;

a++;
b--;

a > b;
a && b;
```

### 泛左值(glvalue, generalized lvalue)

具名，lvalue和xvalue都属于glvalue

### 右值(rvalue, right value)

可被移动的表达式，prvalue和xvalue都属于rvalue

## 引用

在C++11之前，引用分为左值引用和常量左值引用两种，但是自C++11起，引入了右值引用，也就是说，在C++11中，包含如下3中引用：

* 左值引用
* 常量左值引用(不希望被修改)
* 右值引用

## 目录说明

### variable-left

左值

### variable-reference

与引用相关的左右值
