# class-sequential

代码

```cpp
#include <iostream>

class TestA
{
private:
    int n1;
    int n2;
    int n3;

public:
    TestA() : n2(0), n1(n2 + 2), n3(n2 + 2)
    {
    }

    void print()
    {
        std::cout << "n1 = " << n1 << std::endl;
        std::cout << "n2 = " << n2 << std::endl;
        std::cout << "n3 = " << n3 << std::endl;
    }
};

int main()
{
    TestA a;
    a.print();

    return 0;
}
```

结果：

```
n1 = 10025130
n2 = 0
n3 = 2
```



* 成员变量在使用初始化列表初始化时，只与定义成员变量的顺序有关，与构造函数中初始化成员列表的顺序无关。因为成员变量的初始化次序是根据变量在内存中次序有关，而内存中的排列顺序早在编译期就根据变量的定义次序决定了。
* 如果不使用初始化列表初始化，在构造函数内初始化时，此时与成员变量在构造函数中的位置有关。
* 类成员在定义时，是不能初始化的
* 类中const成员常量必须在构造函数初始化列表中初始化。
* 类中static成员变量，必须在类外初始化。

## 变量初始化顺序

* 初始化基类中的静态成员变量和静态代码块，按照在程序中出现的顺序初始化；
* 初始化派生类中的静态成员变量和静态代码块，按照在程序中出现的顺序初始化；
* 初始化基类的普通成员变量和代码块，再执行父类的构造方法；
* 初始化派生的普通成员变量和代码块，在执行子类的构造方法；
